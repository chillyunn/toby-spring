어떤 클래스든 스프링의 빈으로 등록할 때 먼저 검토해야 할 것은 

**싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은가** 하는 점이다.

**상태를 갖고 있고, 멀티스레드 환경에서 안전하지 않은 클래스**를 빈으로 무작정 등록하면 심각한 문제가 발생하기 때문이다.

기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.

UserDao와 userService는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고,
서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하도록 만든 것이다.

=>**단일 책임 원칙(SRP)**

하나의 모듈은 한 가지 책임을 가져야 한다는 의미다(하나의 모듈이 바뀌는 이유는 한 가지여야 한다).

단일 책임 원칙의 장점. 변경이 필요할 때 수정 대상이 명확해진다.

적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고, 애플리케이션 로직과 기술/환경을 분리하는 등의 작업이 필요하다.

=> DI

DI를 통해 PlatformTransactionManager의 생성과 의존관계 설정을 스프링에 맡긴 덕에 완벽하게 트랜잭션 기술에서 자유로운 userService를 가질 수 있게 되었다.

단일 책임 원칙을 잘 지키는 코드
 * 인터페이스 도입
 * DI
단일 책임 원칙 적용의 결과
 * 개방 폐쇄 원칙 준수
 * 모듈간 결합도가 낮아서 서로의 변경이 영향을 주지 않음
 * 변경이 단일 책임에 집중되는 응집도 높음
 * 많은 디자인 패턴이 자연스럽게 적용됨
 * 테스트하기 편함

DI는 모든 스프링 기술의 기반이 되는 핵심엔진이자 원리이며,
스프링이 지지하고 지원하는, 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구다.

스프링을 DI 프레임워크라고 부르는 이유는 스프링이 DI에 담긴 원칙과 이를 응용하는 프로그래밍 모델을 자바 엔터프라이즈 기술의 많은 문제를 해결하는데 적극적으로 활용하고 있기 때문이다.
스프링을 사용하는 개발자가 만드는 애플리케이션 코드 또한 이런 DI를 활용해서 깔끔하고 유연한 코드와 설계를 만들어낼 수 있도록 지원하고 지지해주기 때문이다.

서비스 추상화란 트랜잭션과 같이 기능은 유사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 추상 인터페이스와 일관성 있는 접근 방법을 제공해 주는 것을 말한다.
서비스 추상화란 원활한 테스트만을 위해서도 충분히 가치가 있다.
기술이나 환경이 바뀔 가능성이 있음에도, JavaMail처럼 확장이 불가능하게 설계해놓은 API를 사용해야 하는 경우라면 추상화 계층의 도입을 적극 고려해볼 필요가 있다.
특별히 외부의 리소스와 연동하는 대부분 작업은 추상화의 대상이 될 수 있다.

테스트 대역(Test Double):테스트 환경을 만들어주기 위해, 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있도록 사용하는 오브젝트

테스트 스텁(Test Stub): 테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것. 대표적인 테스트 대역.

일반적으로 테스트 스텁은 메소드를 통해 전달하는 파라미터와 달리, 테스트 코드 내부에서 간접적으로 사용된다. 따라서 Di 등을 통해 미리 의존 오브젝트를 테스트 스텁으로 변경해야 한다.EX) DummyMailSender

목 오브젝트는 스텁처럼 테스트 오브젝트가 정상적으로 실행되도록 도와주면서, 테스트 오브젝트와 자신의 사이에서 일어난 커뮤니케이션 내용을 저장해뒀다가 테스트 결과를 검증하는 데 활용할 수 있게 해준다.

다이내믹 프록시를 생성해주는 팩토리 빈의 장점
* 한번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용할 수 있다. TxProxyFactoryBean

프록시 팩토리 빈의 한계
* 트랜잭션과 같이 비즈니스 로직을 담은 많은 클래스의 메소드에 적용할 필요가 있다면 거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을 막을 수 없다.
* 적용 대상이 늘어나면 타깃과 인터페이스만 다른 비슷한 프록시 팩토리 빈 설정 또한 늘어난다.
* TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다.

---
UserServiceTx는 사용자 관리라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기능을 위임한다.

트랜잭션 경계설정 코드의 분리와 DI를 통한 연결의 장점
* 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
* 트랜잭션의 적용이 필요한지 신경 쓰지 않아도 된다.
* JDBC나 JTA같은 로우레벨의 트랜잭션 API는 물론이고 스프링의 트랜잭션 추상화 API조차 필요 없다.
* 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.

가장 편하고 좋은 테스트 방법: 가능한 한 작은 단위로 쪼개서 테스트 하는 것
테스트가 실패했을 때 그 원인을 찾기 쉽다.
테스트의 의도나 내용이 분명해지고, 만들기도 시워진다.

테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.
테스트를 의존 대상으로부터 분리해서 고립시키는 방법: 테스트를 위한 대역 사용 ex) MailSender와 DummnyMailSender,MockMailSender`

단위 테스트: 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜 테스트하느 ㄴ것
통합 테스트: 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트

테스트 가이드라인
* 항상 단위 테스트를 먼저 고려한다
* 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
* DAO는 DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 하므로 DB까지 연동하는 테스트로 만드는 편이 효과적이다.
* 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다.
* 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트다.

단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다.
의존관계가 없는 단순한 클래스나 세부 로직을 검증하기 위해 메소드 단위로 테스트할 때가 아니라면, 대부분 의존 오브젝트를 필요로 하는 코드를 테스트하게 되기 때문이다.

Mockito 프레임워크: 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 대표적인 프레임워크

프록시: 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것
프록시의 특징: 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.
프록시의 사용 목적:
* 클라이언트가 타깃에 접근하는 방법 제어
* 타깃에 부가적인 기능 부여
* 
데코레이터 패턴: 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
* 컴파일시점에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다. 
* 같은 인터페이스를 구현한 타깃에 여러개의 프록시를 사용할 수 있다.
* 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

프록시 패턴: 클라이언트가 타깃에 접근하는 방식을 변경해준다.
* 타깃의 기능을 확장하거나 추가하지 않는다.
* 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.
그러나 타깃 오브젝트에 대한 레퍼런스가 미리 변경할 경우 적용하면 된다.
* 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신 프록시는 넘겨주는 것이다.
* 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시에 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.
* 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면, 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많다.
* 원격 오브젝트를 이용하는 경우: RMI나 EJB 등을 이용해 다른 서버에 존재하는 오브젝트를 사용해야할 때, 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것 처럼 프록시를 사용하게 할 수 있다.
* 클라이언트의 요청을 받으면 네트워크를 통해 원격의 오브젝트를 실행하고 결과를 받아서 클라이언트에게 돌려준다.
* 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위한 경우 -> 프록시의 특정 메소드를 사용하려고 하면 예외를 발생시킨다.(Collection의 unmodifiableCollection())
* 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어

데코레이터와 프록시의 차이
* 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.
생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야 하기 때문

프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확자앟거나 접근 방법을 제어할 수 있는 유용한 방법.
그러나 많은 개발자는 프록시를 만드는 일이 번거롭게 느껴진다.
* 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다. -> JDK 다이내믹 프록시
* 부가기능 코드가 중복될 가능성이 많다.

스프링의 ProxyFactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.
TxProxyFactoryBean과 달리 ProxyFactoryBeanㅇ느 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다.

ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.
InvocationHandler와 달리 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다.
덕분에 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.
타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능하다.

* 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.
* 다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 ㅁ나들어진다.
* 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.

다이내믹 프록시의 장점
* 대상 인터페이스의 메소드가 많은 경우
* 타깃 타입 제한 필요 없음.

Method.invoke()를 이용해 타깃 오브젝트의 메서드를 호출할 때는 타깃 오브젝트에서 발생하는 예외가 InvocationTargetException으로 한 번 포장돼서 전달된다.
InvocationTargetException 으로 받은 후 getTargetException() 메서드로 중첩되어 있는 예외를 가져와야 한다.

스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다.
다이내믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다. 내부적으로 새로 정의해서 사용하기 때문이다.
따라서 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링의 빈에 정의할 방법이 없다.
다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.

스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러가지 방법을 제공한다. ex) 팩토리 빈
팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈이다.
FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.

MehotdInterceptor로는 메소드 정보와 함께 타깃 오브젝트가 탐긴 MethodInvocation 오브젝트가 전달된다.
MethodInvocation은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에
MethodInterceptor는 부가기능을 제공하는 데만 집중할 수 있따.
MethodInvocation은 일종의 콜백 오브젝트로, proceed() 메소드를 실행 시 타깃 오브젝트의 메소드를 내부적으로 실행해준다.
MethodInvocation 구현 클래스는 일종의 공유 가능한 템플릿처럼 동작한다.
=> JDK dynamic proxy를 직접 사용하는 코드와 ProxyFactoryBean을 직접 사용하는 코드의 가장 큰 차이점이자 장점.
ProxyFactoryBean은 가장 작은단위의 템플릿/콜백 구조를 으용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유 가능함.
JdbcTemplate가 SQL 파라미터 정보에 종속되지 않아 수많은 DAO 메소드가 하나의 JdbcTemplate를 공유할 수 있는 것과 같다.
ProxyFactoryBean에는 여러 개의 MethodInterceptor를 추가할 수있다.
=> ProxyFactoryBean 하나만으로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다.
=> 새로운 부가기능을 추가할 때마다 프록시와 프록시 팩토리 빈도 추가해줘야 한다는 문제 해결
advice: MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트. 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트.
ProxyFactoryBean은 다이내믹 프록시와 달리 프록시가 구현해야 하는 인터페이스를 제공받지 않는다.
setInterfaces()를 통해 구현해야 할 인터페이스를 지정할 수 있지만, 자동으로 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아내어 구현한다.

ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서 메소드 선정 기능을 사용하는 법
MethodInterceptor는 타깃 정보를 갖고 있지 않아 싱글톤 빈으로 등록 가능
-> 트랜잭션 적용 대상 메소드 이름 패턴을 넣어주면 안됨
-> MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남기고, 프록시에 부가기능 적용 메소드를 선택하는 기능 추가하기.
-> 프록시의 핵심 가치는 타깃을 대신해서 클라이언트의 요청을 받아 처리하는 오브젝트
-> 메소드를 선별하는 기능을 프록시로부터 다시 분리하는 편이 낫다 -> 전략패턴 적용가능

ProxyFactoryBean은 두가지 확장 기능은 Advice와 Pointcut을 활용한다.
advice: 부가기능을 제공하는 오브젝트
pointcut: 메소드 선정 알고리즘을 담은 오브젝트
두 가지 모두 여러 프록시에서 공유 가능하도록 만들어지기 때문에 싱글톤 빈으로 등록 가능하다.

클라이언트 -> 프록시 -> 포인트컷 -> 어드바이스(MethodInterceptor) -> Invocation 콜백 -> 타깃 오브젝트

여러 프록시가 공유 가능, 구체적인 부가기능 방식이나 메소드 선정 알고리즘이 바뀌면 구현 클래스만 바꿔서 설정에 넣으면 됨 => OCP를 지키는 구조.
addAdvisor(pointcut,advice)를 통해 어떤 어드바이스에 대해 어떤 포인트컷을 적용할 지 선택한다.
어드바이저:포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능)

프록시 팩토리 빈 방식의 한계
* 부가기능이 타깃 오브젝트마다 새로 만들어지는 문제 -> 어드바이스
* 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 설정정보를 추가해야하는 문제
-> 새로운 타깃이 등장할 때마다 설정은 매번 복사해서 붙이고 target 프로퍼티의 내용을 수정해줘야 한다.
DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기이다.
빈 후처리기는 ``빈 오브젝트의 프로퍼티를 강제로 수정할 수도 있고 별도의 초기화 작업, 빈 오브젝트 자체를 바꿔치기 등의 기능을 수행할 수 있다.
스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록한다.

포인트컷은 오브젝트 내의 메소드를 선택하는 것과 빈 오브젝트 자체를 선택하는 두 가지 기능을 갖췄다.
포인트컷 선정 기능을 모두 적용하려면 먼저 프록시를 적용할 클래스인지 판단한 후 적용 대상 클래스인 경우 어드바이스를 적용할 메소드인지 확인한다.

transactionAdvisor빈은 DefaultAdvisorAutoProxyCreator 덕분에 ProxyFactoryBean으로 등록한 빈에서처럼 transactionAdvisor를 명시적으로 DI 하는 빈은 존재하지않는다.
어드바이저를 이용하는 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator에 의해 자동수집되고, 프록시 대상 선정 과정에 참여하며, 자동생성된 프록시에 다이내믹 하게 DI 돼서 동작하는 어드바이저가 된다.

트랜잭션 어드바이스를 적용한 프록시 자동생성기를 빈 후처리기 매커니즘을 통해 적용했다.
최소한 두 가지는 확인해야 한다.
1. 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가 => 롤백을 통해 트랜잭션 적용 여부 테스트
2. 프록시 자동생성기가 어드바이저 빈에 연결해둔 포인트컷의 클래스 필터를 이용해서 정확히 원하는 빈에만 프록시를 생성했는가 => 포인트컷 빈의 클래스 이름 패턴을 변경해서 적용 여부 테스트

복잡하고 세밀한 기준을 이용해 클래스나 메소드를 선정하는 방법.
1. 리플렉션 API
리플렉션 API를 통해 클래스와 메소드의 이름,패키지,파라미턴,리턴 값,애노테이션,구현한 인터페이스,상속한 클래스 등의 정보를 알 수 있다.
하지만 리플렉션 API는 코드를 작성하기가 번거롭고 조건이 달라질 때마다 포인트컷 구현 코드를 수정해야한다.
2. 포인트컷 표현식: 스프링이 제공해주는 표현식 언어를 사용해서 포인트컷을 작성할 수 있는 방법.

포인트컷 표현식
AspectJExpressionPointCut 클래스 사용.
Pointcut 인터페이스를 구현해야 하는 스프링의 포인트컷은 클래스 선정을 위한 클래스 필터와 메소드 선정을 위한 메소드 매처를 각각 제공해야 한다.
NameMatchClassMethodPointcut은 클래스와 메소드의 이름패턴을 독립적으로 비교하도록 만들어져 있다.
AspectJExpressionPointcut은 클래스와 메소드의 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있게 해준다.

프록시 방식의 AOP 주의사항
* 프록시를 통한 부가기능의 적용은 클라이언트(인터페이스를 통해 타깃 오브젝트를 사용하는 다른 모든 오브젝트)로부터 호출이 일어날 때만 가능하다.
* 타깃 오브젝트가 자기 자신의 메소드를 호출할 때는 프록시를 통한 부가기능의 적용이 일어나지 않는다.
* 타깃의 delete()가 update()를 호출할 경우 update()에 트랜잭션 전파 속성을 REQUIRES_NEW로 설정하더라도 delete()에서 시작한 트랜잭션에 참여한다.
* 타깃에 트랜잭션이 적용되지 않았다면 update()에도 적용되지 않는다.

타깃 내부의 호출에서 프록시가 적용되지 않는 문제를 해결할 수 있는 방법
* 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메소드 호출도 프록시를 이용하도록 강제한다. => 비즈니스 로직에 스프링 API와 프록시 호출 코드가 추가된다.
* 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용한다. ex)AspectJ

트랜잭션 경계설정의 부가기능을 여러 계층에서 중구난방으로 적용하는 건 좋지 않다.
일반적으로 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직하다.
서비스 계층을 트랜잭션이 시작되고 종료되는 경계로 정했다면, 테스트와 같은 특별한 이유가 아니고는 다른 계층이나 모듈에서 DAO에 직접 접근하는 것은 차단해야 한다 => 부가 로직 적용 및 트랜잭션 속성도 제어할 수 있다.


#### 6.7 애노테이션 트랜잭션 속성과 포인트컷
* 포인트컷 표현식과 트랜잭션 속성을 이용해 트랜잭션을 일괄적으로 적용하는 방식 -> 대부분의 상황에 좋다.
* 클래스나 메소드에 따라 세밀하게 튜닝된 트랜잭션 속성을 적용해야 하는 경우 -> @Transactional
---

*@Transactional은 타깃 메소드 -> 타깃 클래스 -> 타입 메소드 -> 타입 클래스로 우선순위가 정해진다.
*@Transactional은 먼저 타입 레벨에 정의하고, 공통 속성을 따르지 않는 메소드에 대해서만 메소드 레벨에 다시 @Transactional을 부여하는 방식이 바람직하다.
* 하지만 인터페이스를 사용하는 프록시 방식의 AOP가 아닌 방식으로 트랜잭션을 적용할 경우 인터페이스의 @Transactional은 무시되므로 타깃 클래스에 적용하는 것이 좋다.
* 인터페이스에 @Transactional을 두면 구현 클래스가 바뀌더라도 트랜잭션 속성을 유지할 수 있다는 장점이 있다.

* @Transactional을 사용하기 위한 tx 스키마 설정
  * <tx:annotation-driven />

* 선언적 트랜잭션: AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법.
* 프로그램에 의한 트랜잭션: TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법
* 대부분 선언적 트랜잭션을 사용하는 것이 바람직하다.

---
* 트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.
  * PlatformTransactionManager 인터페이스를 구현한 트랜잭션 매니저를 통해 구체적인 트랜잭션 기술의 종류에 상관없이 일관된 트랜잭션 제어가 가능했다.
  * 또한 트랜잭션 동기화 기술이 있었기에 시작된 트랜잭션 정보를 저장소에 보관해뒀다가 DAO에서 공유할 수 있었다.
* 트랜잭션 동기화 기술 덕분에 진행 중인 트랜잭션이 있는지 확인하고, 트랜잭션 전파 속성에 따라서 이에 참여할 수 있도록 만들어준다.\
* 특별한 이유가 없다면 트랜잭션 매니저를 직접 이용하는 코드를 작성할 필요는 없다.
* 테스트에서는 트랜잭션 매니저를 통해 유용하게 트랜잭션 제어를 할 수 있다.
  * 스프링의 트랜잭션 추상화가 제공하는 트랜잭션 동기화 기술과 트랜잭션 전파 속성 덕분에 테스트도 트랜잭션으로 묶을 수 있다.
* 선언적 트랜잭션을 적용하지 않아도 JdbcTemplate는 트랜잭션이 시작된 것이 있으면 그 트랜잭션에 자동으로 참여하고, 없으면 트랜잭션 없이 자동 커밋모드로 JDBC 작업을 수행한다.
  
* 롤백 테스트를 통해 DB 작업이 포함된 테스트가 수행되도 DB에 영향을 주지 않기 때문에 장점이 많다.
* 테스트 클래스 또는 메소드에 @Transactional을 부여해주면 마치 타깃 클래스나 인터페이스에 적용된 것 처럼 테스트 메소드에 트랜잭션 경계가 자동으로 설정된다.
* 테스트에 적용된 @Transactional은 기본적으로 트랜잭션을 강제 롤백시키도록 설저되어 있다.
* 테스트 메소드에서 진행되는 작업을 하나의 트랜잭션으로 묶고 싶지만 강제 롤백을 원하지 않을 경우:@Rollback(false)
* 테스트 클래스의 모든 메소드에 롤백되지 않는 트랜잭션을 적용하는 방법:@TransactionConfiguration -> Deprecated. @Commit
* 특정 메서드에만 트랜잭션이 시작되지 않도록 하는법:@NotTransactional OR @Transactional(propagation=Propagation.NEVER)

* 효과적인 DB가 사용되는 통합 테스트를 만드는 법
* 의존,협력 오브젝트를 사용하지 않고 고립된 상태에서 테스트를 진행하는 단위 테스트,
* DB 같은 외부 리소스나 여러 계층의 클래스가 참아혀나는 통합 테스트는 아예 클래스를 구분해서 따로 만드는게 좋다.
* DB가 사용되는 통합 테스트를 별도의 클래스로 만들어둔다면 기본적으로 클래스 레벨에 @Transactional를 부여해준다.
* DB가 사용되는 통합 테스트는 가능한 한 롤백 테스트로 만드는게 좋다.
* 테스트는 어떤 경우에도 서로 의존하면 안 된다.
---

## 스프링의 정의
* 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플레이케이션 프레임워크
#### 애플리케이션 프레임워크
* 특정 계층이나 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크
일반적인 라이브러리나 프레임워크: 특정 업무분야나 한 가지 기술에 특화된 목표를 가지고 만들어짐.
ex) 
* 웹 계층을 MVC구조로 손쉽게 만들 수 있게 한다.
* 포맷과 출력장치를 유연하게 변경할 수 있는 애플리케이션 로그 기능을 제공한다.

#### 스프링의 일차적인 존재 목적
* 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용해서 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 기능을 제공해줌으로써 애플리케이션을 편리하게 개발해주는 애플리케이션 프레임워크

#### 경량화
* 단순한 개발툴과 기본적인 개발환경으로도 엔터프라이즈 개발에서 필요로 하는 주요한 기능을 갖춘 애플리케이션을 개발하기 충분하다.
* 코드가 EJB나 여타 프레임워크에서 동작하기 위해 만들어진 코드에 비해 상대적으로 작고 단순하다.
코드에 불필요하게 등장하던 프레임워크와 서버환경에 의존적인 부분을 제거해주기 때문.

#### 자바 엔터프라이즈 개발을 편하게
* 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서도
애플리케이션의 핵심인 사용자의 요구사항(비즈니스 로직)을 빠르고 효과적으로 구현하는 것\
#### 오픈소스
* 소스를 자유롭게 열람하고, 자신의 목적에 맞게 사용할 수 있을 뿐만 아니라, 마음대로 수정할 수 있고, 수정된 제품과 소스를 다시 공개적으로 배포하는 자유도 허용된다.
* 공개된 커뮤니티 공간 안에서 투명한 방식으로 다양한 참여를 통해 개발되기 때문에 매우 빠르고 유연한 개발이 가능하다.
* 단점: 지속적이고 안정적인 개발이 계속될지가 불확실하다.

#### 자바의 근본적인 목적
객체지향 프로그래밍을 통해 유연하고 확장성 좋은 애플리케이션을 빠르게 만드는 것.
## 엔터프라이즈 개발의 복잡함
#### 기술적인 제약조건과 요구사항이 늘어간다. 
* 엔터프라이즈 시스템: 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템.
* 많은 사용자의 요청을 동시에 처리해야 하기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다.
* 중요한 기업의 핵심 정보를 처리하거나 미션 크리티컬한 금융, 원자력, 항공, 국방 등의 시스템을 다루기도 하기 때문에 보안과 안정성, 확장성 면에도 뛰어나야 한다.
* 뛰어난 성능과 서비스의 안정성이 요구되고 그런 점을 고려한 개발 기술이 필요하다.
* 순수한 비즈니스 로직 + 기술적 고려 사항(웹을 통한 사용자 인터페이스, 타 시스템과의 자동화된 연계, 웹 이외의 클라이언트와의 접속을 위한 리모팅 기술
다중 데이터베이스를 하나의 트랜잭션으로 묶어서 사용하는 분산 트랜잭션 지원 등)

#### 비즈니스 로직의 복잡함이 증가한다.
* 엔터프라이즈 시스템을 이용해 기업의 핵심 업무를 처리하는 비율 증가,
* 다양하고 복잡한 업무 처리 기능을 엔터프라이즈 시스템이 구현해야 한다.
* 기능 요구사항과 업무 정책등이 바뀌기 때문에 애플리케이션을 자주 수정해줘야 하는 시대.
=> 시스템 개발과 유지보수, 추가 개발 등의 작업에 대한 부담은 커지고, 그에 따른 개발 난이도는 더욱 증가함.
## 엔터프라이즈 애플리케이션이 실패하는 주요 원인
* 비즈니스 로직의 복잡함과 기술적인 복잡함(세부 요소가 이해하기 힘든 방식으로 얽혀 있고, 때문에 쉽게 다루기 어렵다.)
* 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다
  * 침투적인 기술: 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우 ex) EJB
  * 비침투적인 기술: 애플리케이션 코드에 불필요하게 나타나지 않고 코드의 설계와 구현 방식을 제한하지 않는다. ex) Spring

#### 복잡함을 상대하는 스프링의 전략
* 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다. -> 서비스 추상화
기술적인 복잡함은 일단 추상화를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스 부분을 분리하고, 환경과 세부기술에 독립적인 접근 인터페이스를 제공
-> 테스트 편의성 증대, 기술에 대한 세부 설정과 환경으로부터 독립적인 코드를 만들 수 있다.
데이터 액세스 예외에 대한 추상화 -> 비즈니스 로직을 담은 서비스 레이어의 코드가 특정 기술이 발생시키는 예외에 종속되지 않고, 불필요하게 예외를 잡거나 throws를 선언해야하는 것 방지
-> 기술을 사용하는 코드도 최적화된 핵심 로직에만 집중가능.
*  기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다 ex) 트랜잭션, 보안, 로깅 등
책임에 따라 계층을 구분하고 그 사이에 서로의 기술과 특성에 의존적인 인터페이스나 예외처리 등을 최대한 제거한다고 할 지라도 근본적으로 엔터프라이즈 서비스를 적용하는 한 이런 문제는 쉽게 해결할 수 없다.
이런 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하기 위한 방법: AOP
AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술.
AOP 적용 전- 기술과 비즈니스 로직이 지저분하게 얽혀서 다루기 힘듦, 기술적인 코드가 여기저기 중복됨=> 기술적인 작업을 처리하는 방식이 변경될 경우 많은 곳 수정 필요
AOP는 기술을 다루는 코드로 인한 복잡함이 기술 그 자체 이상으로 불필요하게 증대되지 않도록 도와주는 가장 강력한 수단.

## 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
기술적인 코드, 침투적인 기술이 가져온 불필요한 흔적 등을 제거하고 나면 순수하게 애플리케에션의 주요 기능과 비즈니스 로직을 담은 코드만 독립적으로 존재하게 됨.
이 중 기술적인 부분과 느슨하게나마 연관되는 데이터 처리 코드나 웹, 리모트 인터페이스 코드 등을 제외하면 비즈니스 로직 코드를 다루는 코드만 남는다.
비즈니스 로직을 담은 코드는 애플리케이션에서 가장 중요한 핵심이 되는 부분이며 업무의 변화에 따라 자주 변경되거나 수정되는 부분이여서 대체로 복잡하다.
예전에는 비즈니스 로직의 상당 부분을 DB에 두었음.
하지만 엔터프라이즈 시스템의 규모가 커지고, 복잡함이 증가하면서 가장 확장하기 힘들고 많은 비용이 드는 공유 자원인 DB에 커다란 부담, 
데이터 액세스를 중심을 로직을 다루면 개발과 유지보수, 테스트가 매우 어려워짐.

DB는 단지 데이터의 영구적인 저장과 복잡한 조건을 가진 검색과 같은 자체적으로 특화된 기능에만 활용,
데이터를 분석하고 가공하고 그에 따라 로직을 처리하는 부분은 확장하기 쉽고, 비용도 싼 애플리케이션 서버 쪽으로 이동함.
오브젝트에 담긴 로직은 테스트가 쉬우며, 목 오브젝트 등을 통해 DB가 없어도 테스트 가능.
CBD와 같은 최신 설계와 개발 기법, 모델링을 중심으로 한 개발 방법은 오브젝트 기반의 설계와 구현에 잘 들어맞는다.

기술과 비즈니스 로직의 복잡함을 해결하는데 스프링이 공통적으로 사용하는 도구 - 객체지향
자바의 기본은 객체지향에 충실한 설계가 가능하도록 단순한 오브젝트로 개발할 수 있고, 객체지향의 설계 기법을 잘 적용할 수 있는 구조를 만들기 위해 DI 같은 유용할 기술을 편하게 적용하도록 돕는 것이 스프링의 기본 전략.
기술적인 복잡함을 효과적으로 다루게 해주는 기법 - DI를 바탕으로 하고 있음(서비스 추상화, 템플릿/콜백, AOP 등).

모든 스프링의 기술과 전략은 객체지향이라는 자바 언어가 가진 강력한 도구를 극대화해서 사용할 수 있도록 돕는 것.

## POJO 프로그래밍
스프링의 정수:엔터프라이즈 서비스 기능(보안,트랜잭션 등)을 POJO에 제공하는 것
-> 엔터프라이즈 서비스 기술과 POOJO라는 애플리케이션 로직을 담은 코드를 분리했다는 뜻
스프링의 주요 기술인 Ioc/DI, AOP, PSA는 애플리케이션을 POJO로 개발할 수 있게 해주는 기능.
#### POJO의 조건
* 특정 규약에 종속되지 않는다.
  * 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다.
* 특정 환경에 종속되지 않는다.
  * 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안된다.
  * 웹 컨트롤러와 연결되서 사용될 것이 뻔하다고 할 지라도 직접적으로 웹이라는 환경으로 제한하는 오브젝트나 API에 의존하면 웹 외의 클라이언트가 사용하지 못하게 된다.
  * 웹 서버에 올리지 않고 독립적으로 테스트하기 힘들어진다.
  * 비즈니스 로직을 담은 코드에 HttpServletRequest나 HttpSession, 캐시와 관련된 API가 등장하거나 웹 프레임워크의 클래스를 직접 이용하면 안된다.
  * 애노테이션을 사용하는 것으로 POJO가 아니라고 할 순 없지만 애노테이션이나 엘리먼트 값에 특정 기술과 환경에 종속적인 정보를 담고 있다면 POJO가 아니다.
* 객체지향적인 자바 언어의 기본에 충실하게 만들어져야 한다.
  * 책임과 역할이 각기 다른 코드를 한 클래스에 몰아넣어 덩치 큰 만능 클래스로 만드는 경우
  * 재사용이 불가능할 정도로 다른 레이어와 영역의 코드와 강한 결합을 가지고 만들어지는 경우
  * 상속과 다형성의 적용으로 처리하면 깔끔한 것을 if/switch 문이 가득 찬 길고 긴 메소드로 작성해놓은 경우
#### POJO의 장점
* 특정 기술과 환경에 종속되지 않는 오브젝트 -> 깔끔한 코드
* 자동화된 테스트에 유리
* 객체지향적인 설계를 자유롭게 적용가능
### POJO 프레임워크
* POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크
* 스프링을 이용하면 엔터프라이즈 애플리케이션의 핵심 로직을 객체지향적인 POJO를 기반으로 깔끔하게 구현,
엔터프라이즈 환경의 각종 서비스와 기술적인 필요를 POJO 방식으로 만들어진 코드에 적용 가능
## 스프링의 기술
* 스프링이 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 세 가지 가능기술
  * IoC/DI
  * AOP
  * PSA
#### IoC/DI
* 두 개의 오브젝트를 분리, 인터페이스를 두고 느슨하게 연결한 뒤, 실제 사용할 대상은 DI를 통해 외부에서 지정하는 이유
-> 유연한 확장이 가능하게 하기 위해서(OCP)
#### DI의 활용 방법
* 핵심기능의 변경
  * DI의 가장 대표적인 적용 방법: 의존 대상의 구현을 바꾸는 것
* 핵심기능의 동적인 변경
  * DI는 기본적으로는 런타임 시에 동적으로 의존 오브젝트를 연결해주는 것, DI 되고 나면 그 후엔 바뀌지 않는다.
  * DI를 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존 대상을 다이내믹하게 변경가능
  * 예)DAO별 다른 DataSource, 사용자별 독립적인 의존 오브젝트 사용, 로그인한 사용자의 같은 오브젝트 적용
* 부가기능의 추가
  * 데코레이터 패턴
  * 트랜잭션 기능 부여
* 인터페이스의 변경
  * 클라이언트가 사용하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우
  * 어댑터 오브젝트를 만들어 DI
* 프록시
  * 필요한 시점에서 실제 사용할 오브젝ㅌ르르 초기화하고 리소스를 준비하게 해주는 지연된 로딩
  * 원격 오브젝틀르 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시
* 템플릿과 콜백
  * 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿과 콜백으로 만들고 DI를 적용
  -> 지저분하게 매번 만들어야 하는 코드를 간결하게 만들 수 있다.
  -> 콜백을 얼마든지 만들어 사용할 수 있다: 개방을 통한 유연한 확장성
  -> 템플릿은 한 번 만들어두면 계속 재사용할 수 있다: 기능의 확장에도 변하지 않는다는 OCP의 폐쇄 원칙
* 싱글톤과 오브젝트 스코프
  * DI 할 오브젝트의 생명주기를 제어가능
  * DI를 프레임워크로 이용한다 -> DI 대상 오브젝트를 컨테이너가 관리한다
  * 오브젝트의 생성부터 관계설정, 이용, 소멸에 이르기까지의 모든 과정을 DI 컨테이너가 주관 -> 오브젝트의 스코프를 자유롭게 제어 가능
  * 하나 또는 소수의 오브젝트가 수많은 클라이언트를 상대로 고성능 서비스를 제공하는 방식은 엔터프라이즈 개발에서 매우 중요
  * 상태를 갖지 않도록 만든 오브젝트가 동시에 여러 스레드의 요청을 처리하는 방식을 적용하려면
  만들어지는 오브젝트의 개수를 제어하는 일이 매우 중요.
    * 전통적인 싱글톤 패턴은 오브젝트에 많은 제약을 가해서 만들어지기 때문에 권장되지 않음
    * 스프링의 DI는 기본적으로 싱글톤으로 오브젝트를 만들어서 사용하게 한다.
    * 컨테이너가 알아서 싱글톤을 만들고 관리하기 때문에 클래스 자체는 싱글톤을 고려하지 않고 자유롭게 설계해도 된다는 장점
  * 때로는 당일 싱글톤이 아니라 임의의 생명주기를 갖는 오브젝트가 필요할 때도 있다
    * 스프링에서는 싱글톤 외에도 다양한 스코프를 갖는 오브젝트를 만들어 DI 가능
      * HTTP 요청당 하나의 오브젝트 생성
      * HTTP 세션당 하나의 오브젝트 생성
* 테스트
  * 여타 오브젝트와 협력해서 동작하는 오브젝틀르 효과적으로 테스트하는 방법: 가능한 한 고립시키는 것
    * 다른 오브젝트와의 사이에서 일어나는 일을 테스트를 위해 조작할 수 있도록 만든다.
    * 자칫 다른 오브젝트와의 협력을 통해 동작하는 기능을 다 허용하고 테스트하다가는 한번에 수십 개의 오브젝트와 DB, 환경까지 모두 테스트해야 하는 부담
      * 테스트할 대상이 의존하는 오브젝트를 ,테스트를 목적으로 만들어진 목 오브젝트로 대체하면 유용함
    * 복잡한 테스트 데이터가 준비되어 있어야 원하는 결과를 가져올 수 있는 DAO를 사용하는 오브젝트가 있다
      * DAO를 이용하는 서비스 오브젝트를 테스트하기 위해서 DAO도 완벽하게 작성되어 있음 확인
      * DAO가 테스트를 위해 적합한 결과를 돌려주도록 필요한 테스트 데이터 까지 모두 준비 필요
        * 의존 오브젝트를 대신해서 스텁 또는 목 오브젝트 같은 테스트 대역을 활용해야 한다
        * di를  위해 만든 수정자 메소드를 사용하면 테스트 코드 안에서 수동으로 목 오브젝트를 주입 가능
        * 테스트용 설정을 별도로 만드는 방법도 존재
* DI의 용도는 디자인 패턴 중에서 오브젝트 합성 방식을 따르는 패턴과 관련이 있음
* 