어떤 클래스든 스프링의 빈으로 등록할 때 먼저 검토해야 할 것은 

**싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은가** 하는 점이다.

**상태를 갖고 있고, 멀티스레드 환경에서 안전하지 않은 클래스**를 빈으로 무작정 등록하면 심각한 문제가 발생하기 때문이다.

기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.

UserDao와 userService는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고,
서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하도록 만든 것이다.

=>**단일 책임 원칙(SRP)**

하나의 모듈은 한 가지 책임을 가져야 한다는 의미다(하나의 모듈이 바뀌는 이유는 한 가지여야 한다).

단일 책임 원칙의 장점. 변경이 필요할 때 수정 대상이 명확해진다.

적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고, 애플리케이션 로직과 기술/환경을 분리하는 등의 작업이 필요하다.

=> DI

DI를 통해 PlatformTransactionManager의 생성과 의존관계 설정을 스프링에 맡긴 덕에 완벽하게 트랜잭션 기술에서 자유로운 userService를 가질 수 있게 되었다.

단일 책임 원칙을 잘 지키는 코드
 * 인터페이스 도입
 * DI
단일 책임 원칙 적용의 결과
 * 개방 폐쇄 원칙 준수
 * 모듈간 결합도가 낮아서 서로의 변경이 영향을 주지 않음
 * 변경이 단일 책임에 집중되는 응집도 높음
 * 많은 디자인 패턴이 자연스럽게 적용됨
 * 테스트하기 편함

DI는 모든 스프링 기술의 기반이 되는 핵심엔진이자 원리이며,
스프링이 지지하고 지원하는, 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구다.

스프링을 DI 프레임워크라고 부르는 이유는 스프링이 DI에 담긴 원칙과 이를 응용하는 프로그래밍 모델을 자바 엔터프라이즈 기술의 많은 문제를 해결하는데 적극적으로 활용하고 있기 때문이다.
스프링을 사용하는 개발자가 만드는 애플리케이션 코드 또한 이런 DI를 활용해서 깔끔하고 유연한 코드와 설계를 만들어낼 수 있도록 지원하고 지지해주기 때문이다.

서비스 추상화란 트랜잭션과 같이 기능은 유사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 추상 인터페이스와 일관성 있는 접근 방법을 제공해 주는 것을 말한다.
서비스 추상화란 원활한 테스트만을 위해서도 충분히 가치가 있다.
기술이나 환경이 바뀔 가능성이 있음에도, JavaMail처럼 확장이 불가능하게 설계해놓은 API를 사용해야 하는 경우라면 추상화 계층의 도입을 적극 고려해볼 필요가 있다.
특별히 외부의 리소스와 연동하는 대부분 작업은 추상화의 대상이 될 수 있다.

테스트 대역(Test Double):테스트 환경을 만들어주기 위해, 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있도록 사용하는 오브젝트

테스트 스텁(Test Stub): 테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것. 대표적인 테스트 대역.

일반적으로 테스트 스텁은 메소드를 통해 전달하는 파라미터와 달리, 테스트 코드 내부에서 간접적으로 사용된다. 따라서 Di 등을 통해 미리 의존 오브젝트를 테스트 스텁으로 변경해야 한다.EX) DummyMailSender

목 오브젝트는 스텁처럼 테스트 오브젝트가 정상적으로 실행되도록 도와주면서, 테스트 오브젝트와 자신의 사이에서 일어난 커뮤니케이션 내용을 저장해뒀다가 테스트 결과를 검증하는 데 활용할 수 있게 해준다.


---
UserServiceTx는 사용자 관리라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기능을 위임한다.

트랜잭션 경계설정 코드의 분리와 DI를 통한 연결의 장점
* 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
* 트랜잭션의 적용이 필요한지 신경 쓰지 않아도 된다.
* JDBC나 JTA같은 로우레벨의 트랜잭션 API는 물론이고 스프링의 트랜잭션 추상화 API조차 필요 없다.
* 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.

가장 편하고 좋은 테스트 방법: 가능한 한 작은 단위로 쪼개서 테스트 하는 것
테스트가 실패했을 때 그 원인을 찾기 쉽다.
테스트의 의도나 내용이 분명해지고, 만들기도 시워진다.

테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.
테스트를 의존 대상으로부터 분리해서 고립시키는 방법: 테스트를 위한 대역 사용 ex) MailSender와 DummnyMailSender,MockMailSender`

단위 테스트: 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜 테스트하느 ㄴ것
통합 테스트: 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트

테스트 가이드라인
* 항상 단위 테스트를 먼저 고려한다
* 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
* DAO는 DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 하므로 DB까지 연동하는 테스트로 만드는 편이 효과적이다.
* 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다.
* 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트다.

단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다.
의존관계가 없는 단순한 클래스나 세부 로직을 검증하기 위해 메소드 단위로 테스트할 때가 아니라면, 대부분 의존 오브젝트를 필요로 하는 코드를 테스트하게 되기 때문이다.

Mockito 프레임워크: 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 대표적인 프레임워크

프록시: 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것
프록시의 특징: 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.
프록시의 사용 목적:
* 클라이언트가 타깃에 접근하는 방법 제어
* 타깃에 부가적인 기능 부여
* 
데코레이터 패턴: 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
* 컴파일시점에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다. 
* 같은 인터페이스를 구현한 타깃에 여러개의 프록시를 사용할 수 있다.
* 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

프록시 패턴: 클라이언트가 타깃에 접근하는 방식을 변경해준다.
* 타깃의 기능을 확장하거나 추가하지 않는다.
* 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.
그러나 타깃 오브젝트에 대한 레퍼런스가 미리 변경할 경우 적용하면 된다.
* 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신 프록시는 넘겨주는 것이다.
* 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시에 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.
* 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면, 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많다.
* 원격 오브젝트를 이용하는 경우: RMI나 EJB 등을 이용해 다른 서버에 존재하는 오브젝트를 사용해야할 때, 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것 처럼 프록시를 사용하게 할 수 있다.
* 클라이언트의 요청을 받으면 네트워크를 통해 원격의 오브젝트를 실행하고 결과를 받아서 클라이언트에게 돌려준다.
* 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위한 경우 -> 프록시의 특정 메소드를 사용하려고 하면 예외를 발생시킨다.(Collection의 unmodifiableCollection())
* 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어

데코레이터와 프록시의 차이
* 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.
생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야 하기 때문

프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확자앟거나 접근 방법을 제어할 수 있는 유용한 방법.
그러나 많은 개발자는 프록시를 만드는 일이 번거롭게 느껴진다.
* 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다. -> JDK 다이내믹 프록시
* 부가기능 코드가 중복될 가능성이 많다.


* 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.
* 다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 ㅁ나들어진다.
* 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.

다이내믹 프록시의 장점
* 대상 인터페이스의 메소드가 많은 경우
* 타깃 타입 제한 필요 없음.

Method.invoke()를 이용해 타깃 오브젝트의 메서드를 호출할 때는 타깃 오브젝트에서 발생하는 예외가 InvocationTargetException으로 한 번 포장돼서 전달된다.
InvocationTargetException 으로 받은 후 getTargetException() 메서드로 중첩되어 있는 예외를 가져와야 한다.

스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다.
다이내믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다. 내부적으로 새로 정의해서 사용하기 때문이다.
따라서 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링의 빈에 정의할 방법이 없다.
다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.

스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러가지 방법을 제공한다. ex) 팩토리 빈
팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈이다.
FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.

MehotdInterceptor로는 메소드 정보와 함께 타깃 오브젝트가 탐긴 MethodInvocation 오브젝트가 전달된다.
MethodInvocation은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에
MethodInterceptor는 부가기능을 제공하는 데만 집중할 수 있따.
MethodInvocation은 일종의 콜백 오브젝트로, proceed() 메소드를 실행 시 타깃 오브젝트의 메소드를 내부적으로 실행해준다.
MethodInvocation 구현 클래스는 일종의 공유 가능한 템플릿처럼 동작한다.
=> JDK dynamic proxy를 직접 사용하는 코드와 ProxyFactoryBean을 직접 사용하는 코드의 가장 큰 차이점이자 장점.
ProxyFactoryBean은 가장 작은단위의 템플릿/콜백 구조를 으용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유 가능함.
JdbcTemplate가 SQL 파라미터 정보에 종속되지 않아 수많은 DAO 메소드가 하나의 JdbcTemplate를 공유할 수 있는 것과 같다.
ProxyFactoryBean에는 여러 개의 MethodInterceptor를 추가할 수있다.
=> ProxyFactoryBean 하나만으로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다.
=> 새로운 부가기능을 추가할 때마다 프록시와 프록시 팩토리 빈도 추가해줘야 한다는 문제 해결
advice: MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트. 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트.
ProxyFactoryBean은 다이내믹 프록시와 달리 프록시가 구현해야 하는 인터페이스를 제공받지 않는다.
setInterfaces()를 통해 구현해야 할 인터페이스를 지정할 수 있지만, 자동으로 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아내어 구현한다.

ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서 메소드 선정 기능을 사용하는 법
MethodInterceptor는 타깃 정보를 갖고 있지 않아 싱글톤 빈으로 등록 가능
-> 트랜잭션 적용 대상 메소드 이름 패턴을 넣어주면 안됨
-> MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남기고, 프록시에 부가기능 적용 메소드를 선택하는 기능 추가하기.
-> 프록시의 핵심 가치는 타깃을 대신해서 클라이언트의 요청을 받아 처리하는 오브젝트
-> 메소드를 선별하는 기능을 프록시로부터 다시 분리하는 편이 낫다 -> 전략패턴 적용가능

ProxyFactoryBean은 두가지 확장 기능은 Advice와 Pointcut을 활용한다.
advice: 부가기능ㅇ르 제공하는 오브젝트
pointcut: 메소드 선정 알고리즘을 담은 오브젝트
두 가지 모두 여러 프록시에서 공유 가능하도록 만들어지기 때문에 싱글톤 빈으로 등록 가능하다.

클라이언트 -> 프록시 -> 포인트컷 -> 어드바이스(MethodInterceptor) -> Invocation 콜백 -> 타깃 오브젝트

여러 프록시가 공유 가능, 구체적인 부가기능 방식이나 메소드 선정 알고리즘이 바뀌면 구현 클래스만 바꿔서 설정에 넣으면 됨 => OCP를 지키는 구조.
addAdvisor(pointcut,advice)를 통해 어떤 어드바이스에 대해 어떤 포인트컷을 적용할 지 선택한다.
어드바이저:포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능)

#### 트랜잭션 서비스 추상화
추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법 적용
-> 비즈니스 로직 코드는 트랜잭션을 어떻게 처리해야 한다는 구체적인 방법과 서버환경에 종속되지 않음.
-> 구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시에 다이내믹하게 연결해 준다는 DI를 활용한 전형적인 접근 방법

트랜잭션 추상화란 결국 인터페이스와 DI를 통해 무엇을 하는지를 남기고,그것을 어떻게 하는지를 분리한 것.

트랜잭션 부가기능을 어디에 적용할 것인가
-> DI를 이용한 데코레이터 패턴 적용
-> 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않으면서 트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조로 변경.

비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드 작성 필요
-> 프록시 팩토리 빈을 이용하여 부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은 포인트컷을 프록시에서 분리하여 여러 프록시에서 사용하도록 변경

트랜잭션 적용 대상 빈마다 일일이 프록시 팩토리 빈을 설정해줘야함
-> 빈 생성 후처리 기법을 이용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법 도입.
-> 패턴을 이용해 자동으로 클래스를 선정하는 확장된 포인트컷 사용.


---
aspect: 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소, 핵심기능에 부가되어 의미를 갖는 특별한 모듈.
애스펙트는 부가될 기능을 정의한 코드인 어드바이스와 어드바이스를 어디에 적용할지를 결정하는 포인트컷을 함께 갖고 있다.

스프링 AOP는 프록시를 이용했기 때문에 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구하지 않는다.
AspectJ는 프록시가 아닌 클래스 파일이나 바이트코드를 수정한다.
AspectJ가 복잡한 방법을 사용하는 이유
* 바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있다.
* 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하다.
* 프록시 사용시 부가기능을 부여할 대상은 클라이언트가 호출할 때 사용하는 메소드로 제한됨.
* 바이트코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가기능을 부여해줄 수 있다.

일반적인 AOP를 적용하는 데는 프록시 방식의 스프링 AOP로도 충분하다.

AOP의 용어
* 타깃: 부가기능을 부여할 대상. 클래스 또는 부가기능 프록시 오브젝트
* 어드바이스: 타깃에게 제공할 부가기능을 담은 모듈
* 조인 포인트: 어드바이스가 적용될 수 있는 위치. 스프링 AOP에서 조인 포인트는 메소드의 실행 단계 뿐이다.
* 포인트컷: 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈.
* 프록시: 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트. DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임해주면서, 그 과정에서 부가기능을 부여함.
* 어드바이저: 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트. 자동 프록시 생성기가 어드바이저를 AOP 작업정보로 활요함. 스프링 AOP에서만 사용되는 용어.
* 애스펙트: 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다.

스프링의 프록시 방식 AOP를 적용하기 위해 최소 네 가지 빈을 등록해야한다.
자동 프록시 생성기 - DefaultAdvisorAutoProxyCreator.
어드바이스 - 부가기능을 구현한 클래스
포인트컷 - AspectJExpressionPointcut
어드바이저 - DefaultPointcutAdvisor



## 계층형 아키텍처
* 책임고 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것
* 데이터 액세스 계층
  * DB나 레거시 시스템과 연동하는 인터페이스 역할
* 서비스 계층
  * 비즈니스 로직
  * DAO 계층을 호출해서 활용 + 기반 서비스 계층(트랜잭션,보안,메일,메시징,스케줄링 ...)
  * POJO로 작성
  * 객체지향적인 설계 기법 적용
  * 쉽게 테스트하고 유연하게 확장 가능
* 프레젠테이션 계층
  * 웹 기반의 UI를 만들어내고 그 흐름을 관리
  * HTTP 프로토콜을 사용하는 서블릿이 바탕
* 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.
* 서비스 계층에서 JDBC의 ResultSet을 사용하면 JDBC라는 특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다.
  * ResultSet을 다루는 코드
  * ResultSet 예외처리 코드
  * SQLException 처리 코드 (JDBC 기술 종속적인 예외)
* 서블릿의 HttpServletRequest나 HttpSession을 서비스 계층 인터페이스 메소드의 파라미터로 사용하면 안된다.
  * 웹 방식의 클라이언트가 아닌 다른 시스템의 요청을 처리해야할 경우 재사용 불가
  * 서비스 계층에서 웹과 관련된 예외 발생 가능성
  * POJO 기반의 빠르고 간단한 단위 테스트 작성 불가
* 계층 사이의 호출은 인터페이스를 통해 이루어져야한다.
  * 인터페이스를 사용하게 한다는 건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는 의미
* DI는 계층을 구분해주지 않으므로 유의
* 중간 계층을 건너뛰어서 관계를 갖지 않는 계층의 빈을 DI 하지 않도록 주의

## 애플리케이션 정보 아키텍쳐
* 엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템
  * 사용자의 작업 상태를 오래 유지할 수 있는 독립 애플리케이션
  * 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지
* 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다.
  * 엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우
  * 오브젝트로 다루는 경우
* 데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순이 값이나 값을 담기 위한 목적을 오브젝트 형태로 취급하는 구조
  * 객체지향 기술이나 언어를 사용하지 않던 시절과 크게 다르지 않다.
  * 특정 비즈니스 로직이 DB 내부 저장 프로시저나 SQL에 담겨 있는 경우가 많다
#### DB/SQL 중심의 로직 구현 방식
* 데이터 중심 구조의 특징
  * 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향
    * 사용자 조회 시 가입일자 필드에서 SQL을 통해 연도를 추출한다
      * SQL의 결과는 컬럼 이름을 키로 갖는 맵에 저장되거나 단순한 오브젝트를 저장해서 전달된다.
      * JSP에서 SQL 절의 컬럼 이름을 그대로 사용해서 화면에 출력한다
      * DB 테이블이 변경되면 맵이나 오브젝트의 요소도 변경되며 뷰의 내용도 변경된다.
    * 모든 계층의 코드는 사용자 조회 업무에 종속된다.
    * 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다.
  * 종속적일 뿐 아니라 배타적이어서 다른 단위 업무에 재사용되기 힘들다.
  * 자바라는 객체지향 언어와 프로그래밍 기술을 사용하지 않더라도 개발 가능
  * 개발하기 쉽다
  * 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시키는 것
  * 변화에 매우 취약하다
  * 중복을 제거하기 어렵다
  * 로직을 DB/SQL에 많이 담을수록 확장성이 떨어진다
    * DB는 확장에 한계가 있으며 매우 큰 비용이 듦
  * 테스트하기 힘들다.
  * 애플리케이션 서버의 비용은 DB보다 저렴하며 안정성도 높아지고 코드를 검증하기도 편리하다
  * DB에는 부하를 가능한 한 주지 않는 간단한 작업만 하고 복잡한 로직은 오브젝트에 담아서 애플리케이션에서 처리하는 것이 낫다
#### 거대한 서비스 계층 방식
* 상대적으로 단순한 DAO 로직을 사용한다.
*  분석, 가공하면서 비즈니스 로직을 서비스 계층에 집중한다.
* 데이터 액세스 계층이나 DB는 비즈니스 로직을 직접 담고 있지 않기 때문에 훨씬 가벼워진다.
* 서비스 계층이 매우 두터워진다.
* 장점
  * 자바 언어의 장점을 활용해 로직 구현 가능
  * 테스트 수월
  * DAO 코드를 여러 비즈니스 로직에서 공유 가능
  * 각 단위 업무별로 독립적인 개발이 가능하여 초기 개발 속도가 빠르다
  * 테스트하기 수월하다
* 단점
  * SQL이 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다 
    * 결합도가 여전히 크다.
  * 서비스 계층 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 중복되기 쉽다
  * 객체지향적 설계를 적용하기 힘들다
  * 개발자별 습관이나 실력에 따라 비슷한 로직이라도 전혀 다른 스타일의 코드가 나온다
  * 변경과 유지보수가 어렵다.
## 오브젝트 중심 아키텍처
* 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 전보를 전송하는데 사용한다.
* 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.
* 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것
  * SQL이나 웹 페이지의 출력 포맷, 입력 폼 등에 종속되지 않는 일관된 형식의 애플리케이션의 정보를 다룰 수 있게 된다.
* DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있다.
* DAO는 자신이 DB에서 가져와서 도메인 모델 오브젝트에 담아주는 정보가 어디서 사용될지 몰라도 된다.
* 서비스 계층은 DAO에서 어떤 SQL을 사용했는지 몰라도 된다.
* 프레젠테이션 계층은 어떤 비즈니스 로직을 거쳤는지 알 필요가 없이 필요한 정보를 화면에 출력하기만 하면 된다.
* 장점
  * 코드가 이해하기 쉽고 로직을 작성하기 수월하다
  * 프레젠테이션 계층에서는 도메인 오브젝트 구조만 알고 있다면 DAO를 작성하지 않았어도 뷰를 미리 만들 수 있다.
* 단점
  * 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 손해가 있다.
    * 도메인 오브젝트의 모든 필드 정보를 채워서 전달하기 때문
      * 필요없는 관계의 오브젝트도 조회된다.
        * DAO를 분리할 수 있지만 분리하면 필요없는 관계의 오브젝트는 null이 된다.
* 해결법
  * 지연된 로딩 기법을 사용한다
    * 최소한의 오브젝트 정보만 읽어두고 필요한 경우 다이내믹하게 DB에서 다시 조회한다.
  * 필드가 너무 많은 테이블이 있다면 자주 사용되는 것을 골라서 별도의 오브젝트로 정의한다.
  * ORM을 사용한다.
#### 빈약한 도메인 오브젝트 방식
* 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않는 경우
* 비즈니스 로직이 서비스 계층에 존재한다.
  * 거대 서비스 계층 방식과 비슷하다
  * 일관된 도메인 오브젝트를 활용하기 때문에 SQL에 의존적인 데이터 방식보다 훨씬 유연하고 간결하다
  * 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 재사용성이 떨어지고 중복이 발생하기 쉽다.
  * 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특징을 잘 살려서 개발할 수 있는 아키텍쳐
#### 풍성한 도메인 오브젝트 방식
* 특정 도메인 오브젝트가 가진 정보와 깊은 관계가 있는 비즈니스 로직을 서비스 계층이 아닌 도메인 오브젝트에 넣는다.
* 서비스 계층의 비즈니스 로직에서 재사용 한다.
* 도메인 오브젝트에 안에 로직을 담아두면 서비스 계층의 메소드에 따로 만드는 것보다 응집도가 높다.
  * 데이터와 그것을 사용하는 기능이 한곳에 모여있기 때문
  * 서비스 계층의 메소드를 사용하기 위해 DI할 필요가 없어진다.
    * 훨씬 간결하고 직관적이며 객체지향적이다.
* 빈약한 도메인 오브젝트 방식과 비슷하지만 훨씬 간결하고 객체지향적
* 객체지향 분석과 설계를 통해 만들어진 도메인 모델의 정보를 정적인 구조뿐 아니라 동적인 동작 방식에도 적극 활용 가능
* 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 비즈니스 로직을 담고 있던 서비스 계층이 사라지는 것은 아님
  * 여러 종류의 도메인 오브젝트의 기능을 조합해서 복잡한 비즈니스 로직을 만드는 경우
  * 도메인 오브젝트는 직접 다른 계층의 오브젝트에 접근할 수 없음
  * 도메인 오브젝트가 DI를 받지 못하는 이유
    * 스프링 컨테이너가 관리하는 오브젝트 = 빈이 아니기 때문
    * DI를 받으려면 자신도 스프링 컨테이너에서 관리되는 빈이어야 한다.
    * 도메인 오브젝트는 애플리케이션의 코드 또는 기타 프레임워크나 라이브러리,JDBC 템플릿 등에 의해 필요할 때마다 새롭게 만들어진다.
  * 로직의 결과를 DB에 저장하거나 메일 발송 등 작업은 도메인 오브젝트에서 불가
* 서비스 계층은 도메인 오브젝트를 DB나 외부 리소스에서 가져오고 변경된 정보나 새로 등록된 정보를 DB에 반영하는 등의 작업 처리
* + 도메인 오브젝트가 갖고 있는 기능이 있다면 활용\
* 장점
  * 서비스 계층의 코드가 간결하다
  * 비즈니스 로직 코드를 이해하기 쉽다
* 빈약한 도메인 오브젝트 방식이 필요한 경우
  * 충실한 도메인 모델링과 도메인 오브젝트 개발이 선행되고 그 내용이 개발자에게 사전에 충분히 공유되지 않았을 때
    * 도메인 오브젝트에 이미 구현된 코드가 있는데도 이용하지 못하고 서비스 계층에 중복을 만들 수 있음
    * 도메인 오브젝트의 코드를 일부 서비스 개발자가 임의로 변경하는 경우
* 도메인 오브젝트에 담을 수 있는 비즈니스 로직
  * 데이터 액세스 계층에서 가져온 내부 데이터 분석
  * 조건에 따라 오브젝트 정보 변경,생성
  * 변경된 정보가 다시 DB 등에 반영되려면 서비스 계층 오브젝트의 부가적인 작업 필요
#### 도메인 계층 방식
* 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식
* 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행됨
  * 서비스 계층에서 사용자가 입력한 정보를 바탕으로 새로운 도메인 오브젝트를 만들었든
  * 데이터 액세스 계층을 통해 도메인 오브젝트를 가져왔든 상관없이
  * 도메인 오브젝트에게 비즈니스 로직의 처리를 요청 가능
  * 도메인 계층으로 들어가면 서비스 계층의 도움 없이도 비즈니스 로직의 대부분 작업을 수행할 수 있다
* 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용 가능
  * 도메인 오브젝트는 스프링에 등록돼서 싱글톤으로 관리되는 빈이 아니기 때문에 다른 빈 DI 불가
    * 스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요
    * 스프링 AOP 대신 AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트 생성시점을 조인 포인트로 사용가능
      * 스프링 빈이 아닌 일반 오브젝트에 AOP 부가기능 적용가능
      * 도메인 오브젝트가 생성되는 시점에 특별한 부가기능을 추가가능
        * 오브젝트가 수정자 메소드나 DI용 애노테이션을 참고해서 DI 가능한 대상을 스프링 컨테이너에서 찾아 DI해주는 기능
        * 도메인 오브젝트가 생성될 때 스프링의 빈 오브젝트를 DI 받을 수 있음
      * 도메인 오브젝트나 데이터 액세스 계층이나 기반 계층의 오브젝트를 이용하도록 만들 수 있음
* 이전의 어떤 방식보다 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있다.
* 도메인 오브젝트의 기능을 조합해서 복잡한 작업을 진행해야 하는 경우 서비스 계층에서 도메인 계층과 협력하는 것이 바람직하다
* 서비스 계층의 비중과 규모는 단순히 도메인 오브젝트를 사용하는 방식에 비해 훨씬 작다
* 도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야할 사항
  * 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야함
    * 모든 계층에서 도메인 오브젝트를 사용한다
      * 가장 쉬운 방법
      * 오브젝트 중심 아키텍처의 장점을 그대로 누림
      * 도메인 오브젝트의 메소드가 중요한 도메인/비즈니스 로직을 담당하므로 프레젠테이션 계층이나 뷰 에서 사용할 경우 위험이 따를 수 있음.
        * 뷰 개발자가 도메인 오브젝트의 비즈니스 로직을 담은 메소드 호출
        * 가이드라인 작성하여 적용
        * 코딩 정책의 적용을 분석할 수 있는 툴 사용
        * AspectJ의 정책/표준 강제화 기능 사용
          * 간단한 포인트컷 표현식만으로 특정 계층의 오브젝트가 사용할 수 있는 메소드의 범위 제한 가능
    * 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것
      * 도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트(DTO)에 도메인 오브젝트의 내용을 복사해서 전달
        * 기능을 갖지 않으므로 사용하기 안전
        * 도메인 오브젝트를 외부 계층의 코드로부터 보호
        * 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를 따로 만들어야하고 이를 매번 변환해줘야 하는 번거로움
        * AOP와 같은 방법을 통해 변환을 자동으로 해줄 필요
* 도메인 계층의 오브젝트는 매우 짧은 시간 동안만 존재했다가 사라지는 것을 반복
  * 도메인 오브젝트는 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문
    * 상태정보를 담고 있기 때문에 여러 스레드가 공유하는 싱글톤이 될 수 없다.
  * DAO나 컨트롤러 또는 스프링 외 라이브러리를 통해 만들어지는 경우가 많기 때문에 빈으로 등록조차 불가
  * 특별한 방법(AspectJ AOP)으로 DI를 해줘야지만 다른 3계층의 빈들과 협력해서 처리 가능함
* 이러한 방식을 택해야 하는 경우
  * 매우 복잡하고 변경이 잦은 도메인을 가졌을 때
    * 복잡한 도메인 구조와 로직을 최대한 도메인 계층의 오브젝트에 반영
    * 도메인 모델과 설계에 변경이 발생했을 때 도메인 계층의 오브젝트도 빠르게 대응해서 변경해주기 위함
    * 도메인 계층은 응집도가 매우 높아 단위 테스트 작성 편리
      * DAO나 외부 서비스 오브젝트와 연동할 때도 도메인 오브젝트 타입을 유지할 수 있기 때문에 목 오브젝트 등을 이용할 수 있기 때문
#### DTO와 리포트 쿼리
* 도메인 계층 방식의 경우 도메인 계층을 벗어난 정보를 DTO라 불리는 특정계층에 종속되지 않는 정보 전달 목적을 가진 단순 오브젝트에 담아 사용
  * DB 쿼리의 실행 결과를 담는 경우(리포트 쿼리)
    * 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 결과를 생성하는 쿼리
## 스프링 애플리케이션을 위한 아키텍쳐 설계
* 계층구조를 어떻게 나눌 것인가
* 애플리케이션 정보를 어떻게 다룰 것인가
* 각 계층에 사용될 구체적인 기술의 종류
* 수직 추상화 계층의 도입
* 세세한 기술조건 결정
### 계층형 아키텍처
* 3계층 구조는 스프링 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조
* 서비스 계층을 굳이 도입하지 않아도 될 만큼 비즈니스 로직이 단순한 경우 서비스와 데이터 액세스 계층 통합가능
  * 데이터 액세스 기술을 사용하면 복잡하고 지저분하게 반복되는 코드가 대부분 제거되고 핵심 데이터 액세스 로직만 남은 간략한 DAO를 가질 수 있음
  * CRUD로 대부분의 기능을 수행할 수 있다면 서비스 계층을 데이터 액세스 계층에 통합하는 것도 나쁘지 않다
  * 이때 트랜잭션 경계설정 위치는 DAO 메소드 
* 프레젠테이션 계층에 서비스 계층을 통합하는 방법
  * DAO는 순수한 DB 인터페이스 역할을 하는 데이터 액세스 기능만 갖게한다
  * 프레젠테이션 계층의 컨트롤러에 조건에 따른 간단한 로직을 적용
  * 권장되지 않음
  * 스프링 AOP를 이용해 트랜잭션의 경계를 설정하기가 애매하기 때문
    * DAO가 트랜잭션의 경계가 되는 경우에는 트랜잭션 전파 기법을 이용해 여러 DAO를 하나의 트랜잭션으로 조합 가능
    * 프레젠테이션 계층의 오브젝트는 트랜잭션 단위로 삼기에는 너무 크고, 트랜잭션 전파를 통해 조합하기 애매함
    * TransactionTemplate를 통해 코드에 의한 트랜잭션 경계설정을 해야하는데 번거로움.
#### 정보 전송 아키텍처
* 스프링의 기본 기술에 가장 잘 들어맞고 쉽게 적용해볼 수 있는 것
  * 오브젝트 중심 아키텍처의 도메인 오브젝트 방식
  * 빈약한 도메인 오브젝트 방식으로 시작하는 것이 가장 쉽다
  * 도메인 오브젝트를 계층 간 정보 전송을 위해 사용
  * DAO는 그 기술이 어떤 것이든 상관없이 서비스 계층에서 요청을 받거나 결과를 돌려줄 때 도메인 오브젝트 형태를 유지
  * 서비스 계층의 비즈니스 로직 또한 도메인 오브젝트를 이용해 작성
    * 가능한 도메인 오브젝트에 단순한 기능이라도 추가해보도력 노력
  * 프레젠테이션 계층에서도 도메인 오브젝트를 직접 활용하기
  * MVC 아키텍쳐,뷰에 전달하는 정보, 폼의 정보에서도 모델은 도메인 오브젝트를 그대로 사용
* DB와 SQL에 많은 비즈니스 로직을 담고 있는 레거시 시스템을 스프링으로 전환하는 경우
  * 일단 데이터 중심의 아키텍처 사용
  * 3계층 기본 구조로 잘 분리할 수만 있다면 DB 중심 접근방법을 사용해서 기존 SQL 재사용
  * 전환 작업 후 검증 후 단계적으로 로직을 DB에서 애플리케이션으로 가져오기, 오브젝트 중심으로 전환 시도
### 상태 관리와 빈 스코프
* 하나의 HTTP 요청의 범위를 넘어 유지해야하는 상태 정보
  * 사용자 로그인 세션 관리
  * 여러 페이지에 걸쳐 진행되는 위저드 기능
* 엔터프라이즈 애플리케이션은 특정 사용자가 독점해서 배타적으로 사용되지 않는다.
* 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하게 함
  * 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식
  * 서버의 자원이 특정 사용자에게 일정하게 할당되지 않는다.
    * 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않는다.
  * 애플리케이션의 상태와 장시간 진행되는 작업정보는 유지해야함
    * URL, 파라미터, 폼 히든 필드, 쿠키 등을 이용해 상태정보 전달
    * 중요한 상태정보는 파일시스템, 데이터그리드 DB에 저장
    * HTTP 세션과 같은 서블릿 컨테이너가 제공하는 저장공간 활용
* 스프링은 기본적으로 상태가 유지되는 빈과 오브젝트를 사용하는 것을 권장
  * 웹의 생리에 가장 잘 들어맞음
  * 개발하기 쉬움
  * 서버 확장이 쉬움
* 웹 클라이언트에 폼 정보를 출력, 수정하는 작업을 위해 HTTP 세션을 활용하기도 함
### 서드파티 프레임워크, 라이브러리 적용
* 표준 기술 외에 많이 사용되는 오픈소스 프레임워크, 라이브러리, 사용제품을 스프링과 함께 사용 가능
* 스프링이 공식적으로 지원하는 기술인지 확인 필요
  * 해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있다.
  * 스프링의 서비스 추상화가 적용됐다.
    * 테스트가 매우 까다롭게 설계된 기술
    * DI 해서 사용하기 불편한 기술
  * 스프링이 지지하는 프로그래밍 모델을 적용했다
  * 템플릿/콜백이 지원된다.
    * 네트워크 접근이나 파일 IO처럼 실패할 가능성이 있는 시도를 하는 기술
    * 사용할 때마다 반복적으로 try/catch/finally 블록이 필요한 기술